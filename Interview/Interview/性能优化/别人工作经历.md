# 主要工作经验
#### 基于Unity的MMORPG项目
- [**行为树**](#行为树) 在服务器端使用c++编写的基于事件驱动的行为树。
- 行为树编辑器 依赖Unity的行为树编辑器，支持行为树导出及实时调试，支持通用子树。
- [**技能系统**](#技能系统) 客户端技能系统的实现。并通过导出root motion使用逻辑层播放增强技能表现，使用CinemachineTargetGroup增强打击感。实现了技能预表现与回滚。
- 副本 在服务器端实现的副本系统，配合服务器的事件、条件、旗标系统，通过策划配置实现不同副本的副本玩法。
- [Shader](#Shader) 角色，怪物，场景，UI特效，UI镜面，场景水面。
- [**网络底层**](#网络底层) 替换原有通信协议变为protobuf，为了减少GC提高解析效率，修改为在c代码侧收发、解析probubuf，并进行解压和解密。
- [UI通用组件](#UI通用组件) 支持任意大小，任意类型子节点的无限循环列表。方便使用的属性列表。变色文字，TextMeshPro图文混排支持使用图集。
- [**性能优化**](#性能优化) 显示效果分级，Shader内存占用优化，配置档内存占用优化，特效渲染层级优化工具。
- [**资源发布与检查工具**](#资源发布与检查工具) 对场景、场景对象、特效等的资源优化与检查.
- 寻路与高度图 记录场景高度图用来查找地图上任意一点地面高度，实现A*寻路。
- [UI框架与配套工具](#UI框架与配套工具) 设计了思路，指导同事完成了一个便于快速开发的UI发布工具，生成通用代码，支持代码热加载等。
- [帮助他人完成](#帮助他人完成) 挂机系统，红点系统，lua行为树，资源混淆方案等。
#### 2D横版ARPG游戏
- 帧同步 两个玩家控制六个角色进行实时帧同步战斗打副本。配套制作了同步验证方案。
- [技能系统2](#技能系统2) 使用json格式配置，技能，Buff，事件三者互相触发、作用实现复杂的实时技能系统。
- UI框架 UI层级管理，生命周期管理。
- 行为树 怪物/机器人行为。
- 反外挂 属性数值非内存中数值。
#### 基于Unity和地理位置的大富翁游戏
- 无缝地图 地图数据预处理，流式地图生成。使用北京地图数据，制作的大富翁游戏，通过滑动屏幕可以在一个大富翁地图中漫游。所有的道路和房屋节点动态生成与销毁.
#### 业余项目
- 基于GO的分布式服务器，出于对之前项目的问题的思考，以及我的工作经验的总结，制作的一个基于GO的分布式服务器。[项目地址](https://github.com/iNeverSleeeeep/INServer)
- 配置档工具 基于对项目现有问题的思考，制作了一个功能、性能强大并且有较大扩展潜力的配置档导出工具。[项目地址](https://github.com/iNeverSleeeeep/Game-Config-Tool)
- Unity对象池 代码简单，扩展性强的Unity对象池。[项目地址](https://github.com/iNeverSleeeeep/GameObjectPool)
- 热更新框架 支持多线程下载、断点续传、稳定可靠的热更新框架。代码简单方便用来学习。[项目地址](https://github.com/iNeverSleeeeep/UpdateResourceTool)
- lua代码热加载框架 不同于常见的package.loaded[path] = nil 方式，一个更易用的lua代码热加载实现。[项目地址](https://github.com/iNeverSleeeeep/tolua)

## 详细说明
#### 行为树 
普通的行为树在树层次较深的时候，每次重新决策的性能压力较大，且重新决策的频率较为频繁，为了解决这个问题，我实现了一套基于事件驱动的行为树。
这种行为树的特点是，重新决策的时机依赖于状态改变，当发生状态改变时，找到**监听这个改变的节点**和**当前正在执行的Action节点**的**公共父节点**，如果**改变节点**的优先级高于**当前节点**，从这个父节点开始重新决策，通过这种方式，既减少了决策深度，又减少了决策频率。状态改变事件及各个节点共享数据通过**黑板**对象（使用map存储数据，提供一组监听map和改变map的接口）。

行为树包含以下四种类型节点
- Action节点 执行逻辑，执行完毕后重新触发决策。
- Service节点 定时刷新状态，修改**黑板**状态。只有当前激活分支上的Service节点可以定时执行。
- Condition节点 判断分支是否可以执行，并且监听**黑板**状态改变，当改变发生并且会改变自身的条件通过性的时候，会触发重新决策。
- Select节点 分支选择节点，提供顺序执行子节点功能和选择执行子节点功能。
[回到顶部](#readme)
#### 技能系统
- 设计时合理使用了较少的代码和状态代码来减少了产生BUG的可能。
- 使用状态机切换技能动作，技能动作可取消后摇，支持连击。
- 因为来用了逻辑执行美术制作的位移动作，技能位移表现很强，技能实时性和交互性也很强。
- 制作了两种震屏方式，策划配置与自动摄像机跟随。摄像机使用Cinemachine实现，Lookat使用的是CinemachineTargetGroup，这个组件的功能是可以在几个节点之间根据权重做差值，我将CinemachineTargetGroup增加了两个目标，脚下和主武器位置，这样如果玩家在执行一个跳起动作时，摄像机会有一定的跟随和振动，效果较好。
- 技能都是客户端先释放，并通知服务器端，如果这次技能释放失败，制作了动作/声音/特效/震屏的重置。
[回到顶部](#readme)
#### Shader
- 场景对象使用了Blinn-Phone光照模型，每个角色主体使用固有色、法线和通道三张贴图。
- 高配下使用了额外的摄像机增加了水面的反射效果。UI中也增加了额外摄像机实现角色脚下的镜面效果。
- 场景的Shader替换为一个最简单的只采样地表贴图和光照贴图的Shader。
[回到顶部](#readme)
#### 网络底层
原有网络模块是做在c#侧，并且消息头使用自定义协议，消息体使用protobuf但是是在lua代码中进行解析。

存在以下三个问题：
1. c#侧向lua侧传递字符数组时，存在较大的GC。
2. 消息头使用自定义协议，与消息体的解析不统一，需要两套代码。
3. 在lua代码中解析protobuf消息性能低下。

为了解决以上问题，我的修改方式是，网络部分使用c代码实现，循环使用一个预申请的*char[]*，保证0GC。协议头也替换为protobuf协议（包含客户端和服务器的修改），然后使用一个c库来作为protobuf的解析，解析效率提高为原本的4倍。
[回到顶部](#readme)
#### UI通用组件
- 无限循环列表 任意类型，任意大小子节点都可以放入无限循环列表，无需预先定义节点大小，无需为子节点添加多余组件，非常易于使用。 根据当前Content和Viewport的大小，调整子节点的位置和数量，达到无限循环列表的功能。因为UGUI没有正式提供根据子节点大小设置当前节点大小的组件（ContentSizeFilter不是为了实现这个功能，使用这个常常会有显示BUG），实现了根据多子节点大小设置父节点大小的通用组件，这个是实现无限循环列表的前提。
- 属性列表 普通的属性列表可能包含较多的子节点，需要预先制作每种子节点的预制，为了提高研发效率，制作了这个属性列表。使用配置档定义属性格式，支持图文混排，不同列数，不同列大小，任意对其方式，自定义任意文本格式与链接跳转。
- TextMeshPro图文混排支持使用图集 运行时取得Sprite的图集，构造为TMP支持的数据格式，放置在TMP的Sprite查找列表中。
[回到顶部](#readme)
#### 性能优化
- 显示效果分级 特效分为高中低三挡，美术制作时通过命名增加l_*，m_*，h_*。工具导出为三个prefab，按需加载。
- Shader内存优化 使用ShaderVariantCollection来减少变体，替换模型内默认Shandard Shader，工具检查全部资源替换Standard Shader。
- 配置档内存优化 使用数组而不是字典来导出配置档，使用原表进行查找，大概减少内存到原始的1/3并且几乎没有性能损失。
- 特效层级优化 特效的渲染层级，根据blend/add混合模式以及使用的材质，进行了渲染的重排序，减少了一定DC。
- 其他 对象池数量上限与使用上限，UI显隐使用cull，摄像机裁剪与后处理等。
[回到顶部](#readme)
#### 资源发布与检查工具
- 场景发布 替换了场景Shader，删除了编辑期节点，删除空节点简化层级。场景用使用的模型重新生成，替换了这些模型的一些默认配置。
- 角色发布 一个逻辑组件的挂载与检查，阴影设置与检查，骨骼按需优化。
- 特效发布 删除空节点简化层级，渲染层级优化，一些性能检查（overdraw，粒子数量）。Shader替换等等。
- 动作发布 动作精度压缩，将AnimationClip从fbx拆出。
[回到顶部](#readme)
#### UI框架与配套工具
- UI预制使用分步同步加载，将一个大的UI通过工具拆成不同的部分（根据这个UI的显示规则），当需要使用到某一个页面时延时实例化出来，但是对使用者（客户端开发）透明。
- 逻辑与数据分离，逻辑可以不重启游戏更新，加快开发效率。
- UI使用两层来处理一些特殊的现实（模糊，变灰度图等）。通过后层UI使用Camera Space渲染并增加后处理组件实现。
- UI拆分工具也实现了对常用组件的代码预生成。
[回到顶部](#readme)
#### 帮助他人完成
- 挂机系统 使用了看门狗的方式 保证挂机不会断掉
- 红点系统 红点系统实际分为数据部分和事件传递显示部分。在事件传递部分使用了一个多对多的事件变化通知框架，并且支持了事件变化的追踪，在出错的时候知道是深恶时候哪里的调用出现了问题。
- lua行为树 模仿服务器的行为树制作的一个基于事件驱动的行为树，由客户端宠物系统使用。
- 资源混淆 为了过审增加的一套资源目录混淆规则。
[回到顶部](#readme)
#### 技能系统2
- 这个技能系统强调角色与角色之间的技能搭配与互动，每一个技能都不是一个简单的伤害或者加血，支持了有约60个不同职业的150个不同的技能。
- 技能有前摇阶段和后摇阶段，在任意时刻可以被打断（根据配置），在后摇阶段可以随意取消。
- 技能，状态，和效果三者之间可以互相产生。效果是技能/效果最终产生的作用，可以是简单的伤害，属性增加，也可以是触发另一个技能或效果。
- 每帧有统一的结算阶段，减少了逻辑阶段的复杂性（例如某个效果导致了角色的死亡）。
[回到顶部](#readme)