### 语言基础
1. 类与对象
>- 对象是对客观事物的抽象，类是对对象的抽象。类是一种抽象的数据类型。
>- 关系是，对象是类的实例，类是对象的模板。对象是通过new className产生的，用来调用类的方法;类的构造方法 。

1. 请简述值类型与引用类型的区别。
>- 值类型继承自**System.ValueType**，引用类型继承自**System.Object**
>- 值类型的数据存储在内存的栈中；而引用类型的变量持有的是数据的引用，数据存储在数据堆中。
>- 值类型存取速度快，引用类型存取速度慢。
>- 值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用
>- 栈的内存分配是自动释放；而堆在.NET中会有GC来释放
>- 值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。
>- C#的值类型包括：结构体（数值类型、bool型、用户定义的结构体），枚举，可空类型。
>- C#的引用类型包括：数组，用户定义的类(class)、接口(interface)、委托(delegate)，object，字符串。

1. 堆(Heap)与栈(Stack)有何区别？
>- stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。
>- stack空间有限，heap的空间是很大的自由区。

1. 结构体(struct)和类(class)有何区别？
>- 结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。
>- 那么结构体就是当成值来使用的，类则通过引用来对实际数据操作

#### 关键字

1. static有什么用途？（请至少说明两种）
>- 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
>- 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
>- 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用


1. 请简述private，public，protected，internal的区别。
>- private：私有成员，在类的内部才可以访问。
>- public：公共成员，完全公开，没有访问限制。
>- protected：保护成员，该类内部和继承中可以访问。
>- internal：当前程序集内可以访问。

1. 请简述ArrayList和List<int>之间的主要区别。
>- ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理），装箱拆箱的操作（费时），
>- List是泛型类，功能跟ArrayList相似，但不存在ArrayList所说的问题。

1. 请简述sealed关键字用在类声明时与函数声明时的作用。
>- 作为类别的时候 不能有子类 
>- 作为函数的修饰符的时候 在子类里不能重写函数

1. ref参数和out参数是什么？有什么区别？
>- ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。
>- 不同点就是输出参数必须对参数进行初始化。
>- ref必须初始化，out 参数必须在函数里赋值。
>- ref参数是引用，out参数为输出参数。

1. Array,linkedlist,vector,hashmap有什么区别

2. 您在什么情况下会用到虚方法(virtual)？它与接口(interface)有什么不同？
>- 子类重新定义父类的某一个方法时，必须把父类的方法定义为virtual
>- 在定义接口中不能有方法体，虚方法可以。
实现时,子类可以不重新定义虚方法，但如果一个类继承接口，那必须实现这个接口。

1. [请描述接口(interface)和抽象类(abstract)之间的不同。](http://www.cnblogs.com/ronli/archive/2011/10/26/2224654.html)
- 相同点
>- 都不能被直接实例化，都可以通过继承实现其抽象方法。
>- 都是面向抽象编程的技术基础，实现了诸多的设计模式。
- 不同点
>- 接口支持多继承；抽象类不能实现多继承。
>- 接口只能定义抽象规则；抽象类既可以定义规则，还可能提供已实现的成员。
>- 接口是一组行为规范；抽象类是一个不完全的类，着重族的概念。
>- 接口可以用于支持回调；抽象类不能实现回调，因为继承不支持。
>- 接口只包含方法、属性、索引器、事件的签名，但不能定义字段和包含实现的方法；抽象类可以定义字段、属性、包含有实现的方法。 
>- 接口可以作用于值类型和引用类型；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。

#### 高级特性

1. 请简述反射的实现原理。
>- 在程序运行时，动态获取 程序集， 类型（class，interface）和类型的成员信息（方法，字段，属性等）。
>- 在程序运行时，动态创建 类型实例，以及调用和方法 动态创建出来的 类型实例的成员。

1. 请简述.Net与Mono之间的关系。
> mono是.net的一个工具，.net只能在windows平台下跑，mono可以跨平台

#### 协程
1. Unity3D是否支持写成多线程程序？如果支持的话要注意什么？
>- 支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。
>- 注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象

1. Unity3D中的协程（coroutine）和C#线程之间的区别是什么？
>- Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 
>- StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。
>- 作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。
>- 缺点：协同程序并非真线程，可能会发生堵塞。

#### GC
1. 1. 托管内存与非托管内存之间的转换
> 托管内存和非托管内存在c#里面可以互相自由的转化，主要通过Marshal类和GCHandle类，编程时只要注意非托管的内存一定要负责好释放就可以了。
- managed memory-> unmanaged memory
GCHandle unmanaged_data_handle = GCHandle.Alloc(_managed_data, GCHandleType.Pinned); //这里将标记_managed_data暂时不能被gc回收，并且固定对象的地址
- un-managed memory->managed memory
Marshal.Copy(unmanaged_ptr, managed_data, 0, length);//将非托管内存拷贝成托管内存，才能在c#里面使用 

4. 简述C#垃圾回收机制[C#中的GC（垃圾回收机制）](https://www.pianshen.com/article/77731496637/)
> - GC(垃圾回收器)只回收托管资源，不回收非托管资源。
> - GC回收是要在合适的时候（CLR觉得应该进行回收的时候）才进行回收。
> - Dispose()Finalize()非托管资源是不由CLR管理，
> - 例如：Image、Socket、StreamWriter、Timer、Tooltip、文件句柄、GDI资源、数据库连接等等资源（这里仅仅列举出几个常用的）。
> - 这些资源GC是不会自动回收的，需要手动释放。

GC注意事项：
1. 只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理
2. 循环引用，网状结构等的实现会变得简单。GC的标志也压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。
3. GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。
4. GC在一个独立的线程中运行来删除不再被引用的内存
5. GC每次运行时会压缩托管堆
6. 你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。
7. 对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数
8. Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer.而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。
9. .NET GC使用"代"(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。
10. GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize,就变成第2代对象，从而在内存中停留更长时间。





